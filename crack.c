/**
 * Description: Just a brute force algorithm to crack letter codes :)
 * 
 * Cracks DES-based (not MD5-based) letter only passwords generated by the crypt() function.
 * Won't work if the password has more than 5 letters (case doesn't matter).
 * 
 * Author: nicktheway
 * Originally made for cs50 pset2 crack.
 */ 

#define _XOPEN_SOURCE
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * The number of the possible combinations of 1, 2, 3, 4 and 5 char words.
 */
const unsigned long MAX_NEEDED_ITERATIONS = 52 + 52*52 + 52*52*52 + 52*52*52*52 + 52*52*52*52*52;

/**
 * Get the next possible word from the brute force algorithm.
 */
char *nextWord();

/**
 * Increase a char value by one.
 *
 * If the value of the char is 'z' it makes it 'A' again and return 1.
 * Else, it increases the char and returns zero.
 *
 * Char sequence: '\0', A, B, ..., Y, Z, a, b, ..., y, z
 */
int increaseChar(char *c);

int main(int argc, char *argv[static argc])
{
    // Accept execution with exactly 2 arguments.
    if (argc != 2)
    {
        printf("Usage: %s hash\n", argv[0]);
        return EXIT_FAILURE;
    }
    // Check for valid hash argument.
    if (strlen(argv[1]) != 13)
    {
        printf("Usage: %s hash\n", argv[0]);
        return EXIT_FAILURE;
    }

    // The second argument of the crypt() is the following string
    // made from the 2 first letters of the hash.
    char salt[3] = {argv[1][0], argv[1][1], '\0'};

    // Brute force algorithm:
    // Tries all the possible words from 'A' to 'zzzzz'
    // A better implementation would have an up to 5 word database
    // and would try all its words first.
    for (unsigned long i = 0; i < MAX_NEEDED_ITERATIONS; i++)
    {
        const char *const oneWord = nextWord();
        const char *const oneHash = crypt(oneWord, salt);

        if (!strcmp(oneHash, argv[1]))
        {
            printf("%s\n", oneWord); // Print the cracked password.
            return EXIT_SUCCESS; // The password was cracked!!
        }
    }

    return EXIT_FAILURE; // The password isn't a five letter character only sequence.
}

char *nextWord()
{
    static char word[6] = { 'A' - 1 };

    // Adds one to the first letter and does
    // word addition.
    int i = 0;
    while (i < 6 && increaseChar(&word[i]))
    {
        i++;
    }

    return word;
}

inline int increaseChar(char *c)
{
    switch (*c)
    {
        case 'Z':       // Reached the end of the capital letters? Continues with the lower-case ones.
            *c = 'a';
            return 0;
        case 'z':       // like adding 1 to 9 -> you make it 0 and add 1 to the next letter.
            *c = 'A';
            return 1;
        case '\0':      // A new letter unlocked!
            *c = 'A';
            return 0;
        default:        // Default case, just increase the letter value.
            *c += 1;
    }
    return 0;
}
